7400 Series Drum Machine
========================

This is a four-channel, sixteen-step percussion synthesizer/sequencer created entirely from discrete logic chips (mostly 74HC-series parts). That's right, no microcontroller or software of any sort. It was created for the Dangerous Prototypes 7400 Contest in a little over one month of spare-time work.

Photos: http://www.flickr.com/photos/74hc595/sets/72157627942539702/

Video: http://www.youtube.com/watch?v=QsSKh7Z2EVs

gEDA schematics are provided, but I've uploaded PDFs as well.

Sound generation
================
Sound is generated by four identical boards, one per voice. Each "voice" board has the following capabilities:

* Adjustable pitch and duration
* Four waveforms: square, sawtooth, triangle, noise
* Decay envelope
* Downward pitch bend

For the sake of the contest, the sounds are generated with digital circuits and a little analog glue. One half of a TLC556 dual timer (the CMOS version of the 556) is used in astable mode to generate an audio clock signal. Frequency is adjusted with a potentiometer, and a switch allows selection of two frequency ranges by connecting the threshold pin to either an 0.01 uF capacitor or an 0.001 uF capacitor.

The other half of the 556 is used in monostable mode and generates the attack pulse. A potentiometer controls the length of the pulse (and thus the duration of the sound.)

The audio clock feeds into a 74HC191 4-bit counter, and a binary weighted resistor DAC is used to convert the 4-bit value into an analog amplitude. This allows the creation of sawtooth and triangle waves.

A rotary switch selects the waveform. In square wave mode, only the most significant bit of the counter is used. In sawtooth wave mode, the 74HC191 is set to count upward, and the output of the DAC is a 4-bit sawtooth wave with positive slope. In triangle wave mode, the '191 alternates between counting upward and downward, by toggling a 74HC74 flip-flop connected to the DOWN/UP pin. Note that this causes the frequency of the triangle wave to be halved.

The other half of the 74HC74 dual flip-flop is used to sample a 1-bit noise source. The noise source is shared between all four sound boards and is simply an inverter with its output fed back to its input (a ring oscillator; more on this later.) The audio clock controls the sample rate, so the "pitch" of the noise can be controlled.

Another 74HC191 is used as an envelope generator. Since most percussive sounds have an instant attack, the envelope generator only provides a decay. This is where things start to get tricky. An LM324 quad op amp is used as a 4-bit digital volume control. But how is this possible!?

The output of the volume control is another 4-bit binary weighted DAC. But in this case, the input "bits" are not digital highs and lows, but the analog oscillator waveform replicated 4 times and buffered through op amps. Each "copy" of the signal is scaled down by a different factor, and their amplitudes are all added together at a summing junction.

Each op amp in the LM324 is set up as a differential (subtracting) amplifier. When an op amp's inverting input (one of the 4 control bits) is 0, the output voltage gets saturated at the negative rail (0 volts, since it's a single-supply op amp), effectively turning off that component.

Additionally, the 4-bit output of the envelope counter is passed through another binary weighted DAC. When pitch bend is on, this value is connected to the control pin of the audio half of the 556. Higher voltages on the control pin result in lower output frequencies, so the positive-going signal from the '191 causes the oscillator's pitch to decay.

The sound effect is activated when the TRIGGER input is pulled to ground. Each sound board also has a manual trigger input connected to a button on the front panel. Since the 74HC191 counters' reset inputs are level-sensitive, not edge-sensitive, an ac-coupling capacitor and pull-up resistors are used to generate a quick pulse when TRIGGER is pulled low. A diode provides protection from the voltage spike generated when TRIGGER goes high again, but in practice I've found things to be OK without it.

Phew, that was quite a lot! And we're just getting started!

Interface
=========

The front panel was designed in Inkscape, printed on a laser printer and glued to a piece of black foam core. (Who needs Ponoko? :p) At the top are the controls for the four sound generators. At the bottom are 16 switches and LEDs, one for each step, a rotary switch that selects the channel to edit, a master clear button, a start/stop button, and a potentiometer to control the tempo.

The 16 step keys are connected in a matrix configuration to a 74C922 keypad encoder. This chip is rare and *expensive* but it's awesome! It scans a 4x4 switch matrix, performs debouncing, and provides a 4-bit output. Sweet!

A 74HC154 is used to multiplex the LEDs. Only one LED needs to be lit at a time, so a single 33 ohm resistor is used for all the LEDs. During playback, the LED for the current step flickers. This is accomplished by using a 74HC85 4-bit comparator to compare the current step number to the multiplexer count. If they're equal, that LED's value is toggled using an XOR gate. (74HC86)

A 555 is used as a push-on/push-off circuit for the start/stop button. An RC circuit ensures it always starts off.

A 2-bit output is derived from the channel select rotary switch using some clever wiring. It's a 3-pole, 4-position switch, and two of the poles are used: one for bit 1 and one for bit 0. For each pole, the appropriate contacts are grounded; add pull-up resistors and you've got a 2-bit encoder!

Oscillators and counters
========================

The drum machine has two main counters: one for multiplexing the LEDs, and one for advancing through each step during playback. A TLC556 generates clock signals for each counter. The LED multiplexing clock (`LEDCLK`) has a fixed rate in the kilohertz range. The frequency of step clock (`STEPCLK`) is adjustable via the tempo knob.

The counters are two halves of a 4520 synchronous counter. The LED multiplexing counter (referred to as `L0-L3` or `Ln`) is advancing constantly. The step counter (`S0-S3` or `Sn`) updates once every step, and only during playback. To ensure that the first beat isn't skipped when playback starts (because the first clock pulse would advance the counter from 0 to 1 before step 0 is triggered) an RC circuit is used on the clock pin to delay the falling clock edge by a few hundred nanoseconds.

Memory
======

The pattern is stored in a 74LS189 static RAM chip (once again, very expensive). It stores sixteen words of 4 bits each. How convenient! 16 words: 16 steps. 4 bits: 4 channels. 

The 74LS189's address input could come from three sources: the LED multiplex counter `Ln`, the step counter `Sn`. or the keyboard encoder (`Kn`) when a step key is pressed. So two 74HC153 dual 4-bit multiplexers are used to multiplex these inputs into the '189's address lines.

On a falling edge of `STEPCLK`, during playback, two pulses are generated with a 74HC123 dual monostable. The first pulse, `/STEP1`, selects `Sn` as the multiplexer's input, to ensure the address lines are set up. A few hundred nanoseconds later, another pulse, `/STEP2`, goes low, and the sound generators' triggers are activated (if the corresponding bit for that channel is 1. Note the '189's outputs are inverted, so a 1 bit stored results in a negative-going output pulse.)

The 2-bit channel value from the rotary switch is used as an input to a 4052 dual analog multiplexer/demultiplexer. Why use an analog part? So I can use one half as a multiplexer and the other as a demultiplexer! The multiplexer half selects which of the 4 data bits to display on the LEDs; this line is connected to an enable input on the 74HC154 LED decoder. (through an XOR gate that allows it to be toggled.)

Writing to memory is interesting. Pressing a step button toggles the appropriate bit. So we need a circuit that conditionally toggles one bit in the 74LS189. Unlike most SRAM chips, the '189 has separate data inputs and outputs, so we feed the outputs back to the inputs, sticking a 74HC86 quad XOR gate in the middle so we can conditionally toggle bits. (Recall that an XOR gate can be used as a controlled inverter.) The outputs of the '189 are already inverted, so when a step button is pressed, the three bits for the unselected channels should be inverted *again*, and the bit for the selected channel should be left alone, so its inverse is written to memory.

This is where the demultiplexer half of the 4052 comes in. Normally, pull-up resistors are connected to the 'B' inputs of the XOR gates, so the output is the inverse of the 'A' input. The demultiplexer pulls the XOR control input for the selected channel to ground, allowing the bit for the selected channel to pass through inverted.

When a step button is pressed, another 74HC123 dual monostable generates two pulses. The first pulse, `/PRESS`, sets up the 74HC153 multiplexers so the encoded key input is used to select the address. The second pulse, `/WR`, occurs a few hundred nanoseconds later, (after the address and data lines have stabilized) and pulls the memory write enable input `/WE` low.

Note that the feedback/bit-toggling scheme appears to work because the 74LS189 has internal buffers on the input and output lines. If it didn't, the instant feedback would cause the output bits would oscillate wildly.

A 74HC08 quad AND gate is also stuck in there to allow memory to be cleared. Normally, the `/CLEAR` signal is high, allowing the data inputs to pass through. When the clear button is pressed, `/CLEAR` goes low, zeroing all four data bits, and the write-enable pin `/WE` is pulled low. Since the address inputs are constantly being updated by the LED multiplexing counter at a very fast rate, all 16 words are cleared in a matter of milliseconds while the button is depressed.

Rather than sacrifice space for another chip, I used a diode AND gate to connect both the `/WR` and `/CLEAR` lines to the '189's `/WE` input.

Triggers
========

As described earlier, the `/STEP2` pulse activates the trigger outputs for each sound generator. This is accomplished with a 74HC32 quad OR gate. When `/STEP2` is high, the outputs are all held high. When `/STEP2` pulses low, channels with 1 bits programmed go low as well. Since the trigger inputs on the sound generators are normally pulled up, diodes are placed on the trigger outputs so they can only sink current, not source it. This allows wire-AND connections with the manual trigger buttons.

Odds and ends
=============

One of the leftover XOR gates on the 74HC86 is configured as a ring oscillator, to act as a 1-bit noise source. I investigated other ways of generating "true" noise, like amplifying avalanche noise from a reverse-biased transistor's PN junction, but they all seem to require high voltages (usually +12 or 18 volts). This whole circuit runs off a single +5V supply.

I put a resistor in the feedback loop of the ring oscillator because massive noise leaked out onto the power rails without it.

The outputs of the four sound generator boards are buffered with an LM324, combined in a passive mixer circuit, reduced to somewhere around line level, buffered again, and output through a capacitor to remove dc components. And that's basically it! Phew!

Total chip count, main board plus 4 "voice" boards: *37*